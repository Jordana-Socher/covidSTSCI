rse_lm25
rse_lm25[1:273]
rse_lm25=na.omit(rse_lm25)
rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
rse_lm25[1:272]
rse_lm25=na.omit(rse_lm25)
rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
rse_lm25[1:270]
rse_lm25=na.omit(rse_lm25)
rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
rse_lm25[1:268]
rse_lm25=na.omit(rse_lm25)
rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
rse_lm25[1:266]
rse_lm25
mean(rse_lm25)
rse_lm50=na.omit(rse_lm50)
rse_lm50=rse_lm25[!is.infinite(rse_lm50)]
rse_lm50
rse_lm50[1:266]
rse_lm50[1:267]
rse_lm50=na.omit(rse_lm50)
rse_lm50=rse_lm25[!is.infinite(rse_lm50)]
rse_lm50=rse_lm50[1:266]
mean(rse_lm50)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
# Model Loop. Iterates over days and runs loess local polynomial regression
# with varying bandwith selections. The model regressors are from selection.R,
# using a general linear approach. Unit of analysis is country on day d.
masterData = masterData[masterData$total_cases < 5000000, ]
masterData = masterData[masterData$deltaGDP > -10000, ]
masterData = masterData[!is.na(masterData$lawRank), ]
# Begin model loop. Iterates over unique days and appends model statistics
# to globalData. Sum of squared error is most valuable here, allowing us to
# track the model's ability to predict the change in GDP from 2019 to 2020 over
# time.
x <- unique(c(masterData$date))
rse_lm25 <- c(replicate(length(x), 0))
rse_lm50 <- c(replicate(length(x), 0))
rse_lm75 <- c(replicate(length(x), 0))
globalData = data.frame()
for (i in 0:length(x)) {
localData = masterData[masterData$date == x[i]]
if (length(localData$Country.or.Area) !=0) {
loessMod25 <- loess(deltaGDP ~lawRank, data=localData, span=0.25) # 25% smoothing span
smoothed25 <- predict(loessMod25)
rse_lm25[i]<-loessMod25$s
loessMod50 <- loess(deltaGDP ~ lawRank, data=localData, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
rse_lm50[i]<-loessMod50$s
loessMod75 <- loess(deltaGDP ~ lawRank, data=localData, span=0.75) # 50% smoothing span
smoothed75 <- predict(loessMod75)
rse_lm75[i]<-loessMod75$s
localData = c(x[i], loessMod25$s, loessMod50$s, loessMod75$s)
globalData <- rbind(globalData, localData)
}
}
rse_lm25=na.omit(rse_lm25)
rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
rse_lm25=rse_lm25[1:266]
mean(rse_lm25)
rse_lm50=na.omit(rse_lm50)
rse_lm50=rse_lm25[!is.infinite(rse_lm50)]
rse_lm50=rse_lm50[1:266]
mean(rse_lm50)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
# Model Loop. Iterates over days and runs loess local polynomial regression
# with varying bandwith selections. The model regressors are from selection.R,
# using a general linear approach. Unit of analysis is country on day d.
masterData = masterData[masterData$total_cases < 5000000, ]
masterData = masterData[masterData$deltaGDP > -10000, ]
masterData = masterData[!is.na(masterData$lawRank), ]
# Begin model loop. Iterates over unique days and appends model statistics
# to globalData. Sum of squared error is most valuable here, allowing us to
# track the model's ability to predict the change in GDP from 2019 to 2020 over
# time.
x <- unique(c(masterData$date))
rse_lm25 <- c(replicate(length(x), 0))
rse_lm50 <- c(replicate(length(x), 0))
rse_lm75 <- c(replicate(length(x), 0))
globalData = data.frame()
for (i in 0:length(x)) {
localData = masterData[masterData$date == x[i]]
if (length(localData$Country.or.Area) !=0) {
loessMod25 <- loess(deltaGDP ~lawRank, data=localData, span=0.25) # 25% smoothing span
smoothed25 <- predict(loessMod25)
rse_lm25[i]<-loessMod25$s
loessMod50 <- loess(deltaGDP ~ lawRank, data=localData, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
rse_lm50[i]<-loessMod50$s
loessMod75 <- loess(deltaGDP ~ lawRank, data=localData, span=0.75) # 50% smoothing span
smoothed75 <- predict(loessMod75)
rse_lm75[i]<-loessMod75$s
localData = c(x[i], loessMod25$s, loessMod50$s, loessMod75$s)
globalData <- rbind(globalData, localData)
}
}
rse_lm25=na.omit(rse_lm25)
rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
rse_lm25=rse_lm25[1:266]
mean(rse_lm25)
rse_lm50=na.omit(rse_lm50)
rse_lm50=rse_lm50[!is.infinite(rse_lm50)]
rse_lm50=rse_lm50[1:266]
mean(rse_lm50)
rse_lm75=na.omit(rse_lm75)
rse_lm75=rse_lm75[!is.infinite(rse_lm75)]
rse_lm75[1:266]
rse_lm75[1:267]
rse_lm75[1:268]
rse_lm75[1:275]
rse_lm75[1:280]
rse_lm50=na.omit(rse_lm50)
rse_lm50=rse_lm50[!is.infinite(rse_lm50)]
rse_lm50[1:270]
mean(rse_lm50)
rse_lm50[1:266]
rse_lm50[1:267]
rse_lm50=na.omit(rse_lm50)
rse_lm50=rse_lm50[!is.infinite(rse_lm50)]
rse_lm50=rse_lm50[1:266]
mean(rse_lm50)
rse_lm75=na.omit(rse_lm75)
rse_lm75=rse_lm75[!is.infinite(rse_lm75)]
rse_lm75[1:290]
rse_lm75[1:300]
rse_lm75[1:295]
rse_lm75[1:294]
rse_lm75=na.omit(rse_lm75)
rse_lm75=rse_lm75[!is.infinite(rse_lm75)]
rse_lm75=rse_lm75[1:294]
mean(rse_lm75)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
# Model Loop. Iterates over days and runs loess local polynomial regression
# with varying bandwith selections. The model regressors are from selection.R,
# using a general linear approach. Unit of analysis is country on day d.
masterData = masterData[masterData$total_cases < 5000000, ]
masterData = masterData[masterData$deltaGDP > -10000, ]
masterData = masterData[!is.na(masterData$lawRank), ]
# Begin model loop. Iterates over unique days and appends model statistics
# to globalData. Sum of squared error is most valuable here, allowing us to
# track the model's ability to predict the change in GDP from 2019 to 2020 over
# time.
x <- unique(c(masterData$date))
rse_lm25 <- c(replicate(length(x), 0))
rse_lm50 <- c(replicate(length(x), 0))
rse_lm75 <- c(replicate(length(x), 0))
globalData = data.frame()
for (i in 0:length(x)) {
localData = masterData[masterData$date == x[i]]
if (length(localData$Country.or.Area) !=0) {
loessMod25 <- loess(deltaGDP ~lawRank, data=localData, span=0.25) # 25% smoothing span
smoothed25 <- predict(loessMod25)
rse_lm25[i]<-loessMod25$s
loessMod50 <- loess(deltaGDP ~ lawRank, data=localData, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
rse_lm50[i]<-loessMod50$s
loessMod75 <- loess(deltaGDP ~ lawRank, data=localData, span=0.75) # 50% smoothing span
smoothed75 <- predict(loessMod75)
rse_lm75[i]<-loessMod75$s
localData = c(x[i], loessMod25$s, loessMod50$s, loessMod75$s)
globalData <- rbind(globalData, localData)
}
}
rse_lm25=na.omit(rse_lm25)
rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
rse_lm25=rse_lm25[1:266]
mean(rse_lm25)
rse_lm50=na.omit(rse_lm50)
rse_lm50=rse_lm50[!is.infinite(rse_lm50)]
rse_lm50=rse_lm50[1:266]
mean(rse_lm50)
rse_lm75=na.omit(rse_lm75)
rse_lm75=rse_lm75[!is.infinite(rse_lm75)]
rse_lm75=rse_lm75[1:294]
mean(rse_lm75)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
x <- unique(c(masterData$date))
aics <- c(replicate(length(x), 0))
masterData = masterData[!is.na(masterData$total_deaths), ]
masterData = masterData[!is.na(masterData$stabilityRank), ]
masterData = masterData[!is.na(masterData$lawRank), ]
masterData = masterData[!is.na(masterData$accountRank), ]
masterData = masterData[masterData$total_deaths != 0.0, ]
masterData = masterData[masterData$stabilityRank != 0.0, ]
masterData = masterData[masterData$lawRank != 0.0, ]
masterData = masterData[masterData$accountRank != 0.0, ]
count = 0
rse_gl <- c(replicate(length(x), 0))
for (index in 1:length(x)){
covidData <-  masterData[masterData$date == x[index]]
print(" ")
#Linear Regression
if (length(covidData$total_deaths) > 10){
r = glm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
df<-summary(r)$df.residual
dev<-summary(r)$deviance
rse_gl[index]<-(dev/df)**(1/2)
aics[index] <- summary(r)$aic
}else{
print(x[index])
count = count + 1
}
}
rse_gl=na.omit(rse_gl)
rse_glm=mean(rse_gl)
rse_glm
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
x <- unique(c(masterData$date))
r2s <- c(replicate(length(x), 0))
masterData = masterData[!is.na(masterData$total_deaths), ]
masterData = masterData[!is.na(masterData$stabilityRank), ]
masterData = masterData[!is.na(masterData$lawRank), ]
masterData = masterData[!is.na(masterData$accountRank), ]
masterData = masterData[masterData$total_deaths != 0.0, ]
masterData = masterData[masterData$stabilityRank != 0.0, ]
masterData = masterData[masterData$lawRank != 0.0, ]
masterData = masterData[masterData$accountRank != 0.0, ]
count = 0
rse <- c(replicate(length(x), 0))
for (index in 1:length(x)){
covidData <-  masterData[masterData$date == x[index]]
print(" ")
#Linear Regression
if (length(covidData$total_deaths) > 10){
r = lm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
rse[index]<-summary(r)$sigma
r2s[index] <- summary(r)$r.squared
}else{
print(x[index])
count = count + 1
}
}
rse=na.omit(rse)
rse_lm=mean(rse)
rse_lm
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
x <- unique(c(masterData$date))
r2s <- c(replicate(length(x), 0))
masterData = masterData[!is.na(masterData$total_deaths), ]
masterData = masterData[!is.na(masterData$stabilityRank), ]
masterData = masterData[!is.na(masterData$lawRank), ]
masterData = masterData[!is.na(masterData$accountRank), ]
masterData = masterData[masterData$total_deaths != 0.0, ]
masterData = masterData[masterData$stabilityRank != 0.0, ]
masterData = masterData[masterData$lawRank != 0.0, ]
masterData = masterData[masterData$accountRank != 0.0, ]
count = 0
rse <- c(replicate(length(x), 0))
for (index in 1:length(x)){
covidData <-  masterData[masterData$date == x[index]]
print(" ")
#Linear Regression
if (length(covidData$total_deaths) > 10){
r = lm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
rse[index]<-summary(r)$sigma
r2s[index] <- summary(r)$r.squared
}else{
print(x[index])
count = count + 1
}
}
rse=na.omit(rse)
sum(rse)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
x <- unique(c(masterData$date))
aics <- c(replicate(length(x), 0))
masterData = masterData[!is.na(masterData$total_deaths), ]
masterData = masterData[!is.na(masterData$stabilityRank), ]
masterData = masterData[!is.na(masterData$lawRank), ]
masterData = masterData[!is.na(masterData$accountRank), ]
masterData = masterData[masterData$total_deaths != 0.0, ]
masterData = masterData[masterData$stabilityRank != 0.0, ]
masterData = masterData[masterData$lawRank != 0.0, ]
masterData = masterData[masterData$accountRank != 0.0, ]
count = 0
rse_gl <- c(replicate(length(x), 0))
for (index in 1:length(x)){
covidData <-  masterData[masterData$date == x[index]]
print(" ")
#Linear Regression
if (length(covidData$total_deaths) > 10){
r = glm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
df<-summary(r)$df.residual
dev<-summary(r)$deviance
rse_gl[index]<-(dev/df)**(1/2)
aics[index] <- summary(r)$aic
}else{
print(x[index])
count = count + 1
}
}
rse_gl=na.omit(rse_gl)
sum(rse_gl)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
# Model Loop. Iterates over days and runs loess local polynomial regression
# with varying bandwith selections. The model regressors are from selection.R,
# using a general linear approach. Unit of analysis is country on day d.
masterData = masterData[masterData$total_cases < 5000000, ]
masterData = masterData[masterData$deltaGDP > -10000, ]
masterData = masterData[!is.na(masterData$lawRank), ]
# Begin model loop. Iterates over unique days and appends model statistics
# to globalData. Sum of squared error is most valuable here, allowing us to
# track the model's ability to predict the change in GDP from 2019 to 2020 over
# time.
x <- unique(c(masterData$date))
rse_lm25 <- c(replicate(length(x), 0))
rse_lm50 <- c(replicate(length(x), 0))
rse_lm75 <- c(replicate(length(x), 0))
globalData = data.frame()
for (i in 0:length(x)) {
localData = masterData[masterData$date == x[i]]
if (length(localData$Country.or.Area) !=0) {
loessMod25 <- loess(deltaGDP ~lawRank, data=localData, span=0.25) # 25% smoothing span
smoothed25 <- predict(loessMod25)
rse_lm25[i]<-loessMod25$s
loessMod50 <- loess(deltaGDP ~ lawRank, data=localData, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
rse_lm50[i]<-loessMod50$s
loessMod75 <- loess(deltaGDP ~ lawRank, data=localData, span=0.75) # 50% smoothing span
smoothed75 <- predict(loessMod75)
rse_lm75[i]<-loessMod75$s
localData = c(x[i], loessMod25$s, loessMod50$s, loessMod75$s)
globalData <- rbind(globalData, localData)
}
}
rse_lm25=na.omit(rse_lm25)
rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
rse_lm25=rse_lm25[1:266]
sum(rse_lm25)
rse_lm50=na.omit(rse_lm50)
rse_lm50=rse_lm50[!is.infinite(rse_lm50)]
rse_lm50=rse_lm50[1:266]
sum(rse_lm50)
rse_lm75=na.omit(rse_lm75)
rse_lm75=rse_lm75[!is.infinite(rse_lm75)]
rse_lm75=rse_lm75[1:294]
sum(rse_lm75)
#only used 1:266 or 1:294 because the rest were NA
#rse_lm25=na.omit(rse_lm25)
#rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
#rse_lm25=rse_lm25[1:266]
sum(rse_lm25)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
# Model Loop. Iterates over days and runs loess local polynomial regression
# with varying bandwith selections. The model regressors are from selection.R,
# using a general linear approach. Unit of analysis is country on day d.
masterData = masterData[masterData$total_cases < 5000000, ]
masterData = masterData[masterData$deltaGDP > -10000, ]
masterData = masterData[!is.na(masterData$lawRank), ]
# Begin model loop. Iterates over unique days and appends model statistics
# to globalData. Sum of squared error is most valuable here, allowing us to
# track the model's ability to predict the change in GDP from 2019 to 2020 over
# time.
x <- unique(c(masterData$date))
rse_lm25 <- c(replicate(length(x), 0))
rse_lm50 <- c(replicate(length(x), 0))
rse_lm75 <- c(replicate(length(x), 0))
globalData = data.frame()
for (i in 0:length(x)) {
localData = masterData[masterData$date == x[i]]
if (length(localData$Country.or.Area) !=0) {
loessMod25 <- loess(deltaGDP ~lawRank, data=localData, span=0.25) # 25% smoothing span
smoothed25 <- predict(loessMod25)
rse_lm25[i]<-loessMod25$s
loessMod50 <- loess(deltaGDP ~ lawRank, data=localData, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
rse_lm50[i]<-loessMod50$s
loessMod75 <- loess(deltaGDP ~ lawRank, data=localData, span=0.75) # 50% smoothing span
smoothed75 <- predict(loessMod75)
rse_lm75[i]<-loessMod75$s
localData = c(x[i], loessMod25$s, loessMod50$s, loessMod75$s)
globalData <- rbind(globalData, localData)
}
}
#only used 1:266 or 1:294 because the rest were NA
#rse_lm25=na.omit(rse_lm25)
#rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
#rse_lm25=rse_lm25[1:266]
sum(rse_lm25)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
# Model Loop. Iterates over days and runs loess local polynomial regression
# with varying bandwith selections. The model regressors are from selection.R,
# using a general linear approach. Unit of analysis is country on day d.
masterData = masterData[masterData$total_cases < 5000000, ]
masterData = masterData[masterData$deltaGDP > -10000, ]
masterData = masterData[!is.na(masterData$lawRank), ]
# Begin model loop. Iterates over unique days and appends model statistics
# to globalData. Sum of squared error is most valuable here, allowing us to
# track the model's ability to predict the change in GDP from 2019 to 2020 over
# time.
x <- unique(c(masterData$date))
rse_lm25 <- c(replicate(length(x), 0))
rse_lm50 <- c(replicate(length(x), 0))
rse_lm75 <- c(replicate(length(x), 0))
globalData = data.frame()
for (i in 0:length(x)) {
localData = masterData[masterData$date == x[i]]
if (length(localData$Country.or.Area) !=0) {
loessMod25 <- loess(deltaGDP ~lawRank, data=localData, span=0.25) # 25% smoothing span
smoothed25 <- predict(loessMod25)
rse_lm25[i]<-loessMod25$s
loessMod50 <- loess(deltaGDP ~ lawRank, data=localData, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
rse_lm50[i]<-loessMod50$s
loessMod75 <- loess(deltaGDP ~ lawRank, data=localData, span=0.75) # 50% smoothing span
smoothed75 <- predict(loessMod75)
rse_lm75[i]<-loessMod75$s
localData = c(x[i], loessMod25$s, loessMod50$s, loessMod75$s)
globalData <- rbind(globalData, localData)
}
}
#only used 1:266 or 1:294 because the rest were NA or inf values
rse_lm25=na.omit(rse_lm25)
rse_lm25=rse_lm25[!is.infinite(rse_lm25)]
rse_lm25=rse_lm25[1:266]
sum_rse_lm25=sum(rse_lm25)
mean_rse_lm25=mean(rse_lm25)
rse_lm50=na.omit(rse_lm50)
rse_lm50=rse_lm50[!is.infinite(rse_lm50)]
rse_lm50=rse_lm50[1:266]
sum_rse_lm50=sum(rse_lm50)
mean_rse_lm50=mean(rse_lm50)
rse_lm75=na.omit(rse_lm75)
rse_lm75=rse_lm75[!is.infinite(rse_lm75)]
rse_lm75=rse_lm75[1:294]
sum_rse_lm75=sum(rse_lm75)
mean_rse_lm75=mean(rse_lm75)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
x <- unique(c(masterData$date))
aics <- c(replicate(length(x), 0))
masterData = masterData[!is.na(masterData$total_deaths), ]
masterData = masterData[!is.na(masterData$stabilityRank), ]
masterData = masterData[!is.na(masterData$lawRank), ]
masterData = masterData[!is.na(masterData$accountRank), ]
masterData = masterData[masterData$total_deaths != 0.0, ]
masterData = masterData[masterData$stabilityRank != 0.0, ]
masterData = masterData[masterData$lawRank != 0.0, ]
masterData = masterData[masterData$accountRank != 0.0, ]
count = 0
rse_gl <- c(replicate(length(x), 0))
for (index in 1:length(x)){
covidData <-  masterData[masterData$date == x[index]]
print(" ")
#Linear Regression
if (length(covidData$total_deaths) > 10){
r = glm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
df<-summary(r)$df.residual
dev<-summary(r)$deviance
rse_gl[index]<-(dev/df)**(1/2)
aics[index] <- summary(r)$aic
}else{
print(x[index])
count = count + 1
}
}
rse_gl=na.omit(rse_gl)
sum_rse_gl=sum(rse_gl)
mean_rse_gl=mean(rse_gl)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
x <- unique(c(masterData$date))
r2s <- c(replicate(length(x), 0))
masterData = masterData[!is.na(masterData$total_deaths), ]
masterData = masterData[!is.na(masterData$stabilityRank), ]
masterData = masterData[!is.na(masterData$lawRank), ]
masterData = masterData[!is.na(masterData$accountRank), ]
masterData = masterData[masterData$total_deaths != 0.0, ]
masterData = masterData[masterData$stabilityRank != 0.0, ]
masterData = masterData[masterData$lawRank != 0.0, ]
masterData = masterData[masterData$accountRank != 0.0, ]
count = 0
rse <- c(replicate(length(x), 0))
for (index in 1:length(x)){
covidData <-  masterData[masterData$date == x[index]]
print(" ")
#Linear Regression
if (length(covidData$total_deaths) > 10){
r = lm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
rse[index]<-summary(r)$sigma
r2s[index] <- summary(r)$r.squared
}else{
print(x[index])
count = count + 1
}
}
rse=na.omit(rse)
sum_rse_lm=sum(rse)
mean_rse_lm=mean(rse)
