hist(masterData$gdp_per_capita)
summary(masterData$gdp2019)
hist(masterData$gdp2019)
summary(masterData$gdp2020)
hist(masterData$gdp2020)
par(old.par)
summary(masterData$lawRank)
old.par <- par(mfrow=c(2, 5))
hist(masterData$lawRank, main="Law Rank", ylab="Law Rank")
summary(masterData$accountRank)
hist(masterData$accountRank)
summary(masterData$total_deaths)
hist(masterData$total_deaths)
summary(masterData$regulationRank)
hist(masterData$regulationRank)
summary(masterData$govRank)
hist(masterData$govRank)
summary(masterData$corruptionRank)
hist(masterData$corruptionRank)
summary(masterData$total_cases)
hist(masterData$total_cases)
summary(masterData$gdp_per_capita)
hist(masterData$gdp_per_capita)
summary(masterData$gdp2019)
hist(masterData$gdp2019)
summary(masterData$gdp2020)
hist(masterData$gdp2020)
par(old.par)
summary(masterData$lawRank)
old.par <- par(mfrow=c(2, 5))
hist(masterData$lawRank, main="Law Rank", ylab="Law Rank")
summary(masterData$accountRank)
hist(masterData$accountRank, main="Account Rank", ylab="Account Rank")
summary(masterData$total_deaths)
hist(masterData$total_deaths, main="Total Deaths", ylab="Total Deaths")
summary(masterData$regulationRank)
hist(masterData$regulationRank, main="Regulation Rank", ylab="Regulation Rank")
summary(masterData$govRank)
hist(masterData$govRank, main="Gov Rank", ylab="Gov Rank")
summary(masterData$corruptionRank)
hist(masterData$corruptionRank, main="Corruption Rank", ylab="Corruption Rank")
summary(masterData$total_cases)
hist(masterData$total_cases, main="Total Cases", ylab="Total Cases")
summary(masterData$gdp_per_capita)
hist(masterData$gdp_per_capita, , main="GDP Per Capita", ylab="GDP Per Capita")
summary(masterData$gdp2019)
hist(masterData$gdp2019, main="GDP 2019", ylab="GDP 2019")
summary(masterData$gdp2020)
hist(masterData$gdp2020, main="GDP 2020", ylab="GDP 2020")
par(old.par)
summary(masterData$lawRank)
old.par <- par(mfrow=c(2, 5))
hist(masterData$lawRank, main="Law Rank", xlab="Law Rank")
summary(masterData$accountRank)
hist(masterData$accountRank, main="Account Rank", xlab="Account Rank")
summary(masterData$total_deaths)
hist(masterData$total_deaths, main="Total Deaths", xlab="Total Deaths")
summary(masterData$regulationRank)
hist(masterData$regulationRank, main="Regulation Rank", xlab="Regulation Rank")
summary(masterData$govRank)
hist(masterData$govRank, main="Gov Rank", xlab="Gov Rank")
summary(masterData$corruptionRank)
hist(masterData$corruptionRank, main="Corruption Rank", xlab="Corruption Rank")
summary(masterData$total_cases)
hist(masterData$total_cases, main="Total Cases", xlab="Total Cases")
summary(masterData$gdp_per_capita)
hist(masterData$gdp_per_capita, , main="GDP Per Capita", xlab="GDP Per Capita")
summary(masterData$gdp2019)
hist(masterData$gdp2019, main="GDP 2019", xlab="GDP 2019")
summary(masterData$gdp2020)
hist(masterData$gdp2020, main="GDP 2020", xlab="GDP 2020")
par(old.par)
View(masterData)
x=masterData%>%%>%group_by(Country.or.Area)%>%summarise(lawRank, accountRank)
x=masterData%>%group_by(Country.or.Area)%>%summarise(lawRank, accountRank)
library(dplyr)
library(tidyr)
x=masterData%>%group_by(Country.or.Area)%>%summarise(lawRank, accountRank)
View(x)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
x <- unique(c(masterData$date))
r2s <- c(replicate(length(x), 0))
masterData = masterData[!is.na(masterData$total_deaths), ]
masterData = masterData[!is.na(masterData$stabilityRank), ]
masterData = masterData[!is.na(masterData$lawRank), ]
masterData = masterData[!is.na(masterData$accountRank), ]
masterData = masterData[masterData$total_deaths != 0.0, ]
masterData = masterData[masterData$stabilityRank != 0.0, ]
masterData = masterData[masterData$lawRank != 0.0, ]
masterData = masterData[masterData$accountRank != 0.0, ]
count = 0
for (index in 1:length(x)){
covidData <-  masterData[masterData$date == x[index]]
print(" ")
#Linear Regression
if (length(covidData$total_deaths) > 10){
r = lm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
r2s[index] <- summary(r)$r.squared
}else{
print(x[index])
count = count + 1
}
}
r2s[r2s == 1.0] = 0.0
for (ind in 1:length(r2s)){
if (r2s[ind] == max(r2s)){
print(x[ind])
}
}
covidData <-masterData[masterData$date == "2020-03-10"]
#Linear Regression
r = lm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
summary(r)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
x <- unique(c(masterData$date))
aics <- c(replicate(length(x), 0))
masterData = masterData[!is.na(masterData$total_deaths), ]
masterData = masterData[!is.na(masterData$stabilityRank), ]
masterData = masterData[!is.na(masterData$lawRank), ]
masterData = masterData[!is.na(masterData$accountRank), ]
masterData = masterData[masterData$total_deaths != 0.0, ]
masterData = masterData[masterData$stabilityRank != 0.0, ]
masterData = masterData[masterData$lawRank != 0.0, ]
masterData = masterData[masterData$accountRank != 0.0, ]
count = 0
for (index in 1:length(x)){
covidData <-  masterData[masterData$date == x[index]]
print(" ")
#Linear Regression
if (length(covidData$total_deaths) > 10){
r = glm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
aics[index] <- summary(r)$aic
}else{
print(x[index])
count = count + 1
}
}
aics[aics == -Inf] = Inf
aics[aics == 0.0] = Inf
for (ind in 1:length(aics)){
if (aics[ind] == min(aics)){
print(x[ind])
}
}
covidData <-masterData[masterData$date == "2020-03-08"]
#Linear Regression
r = glm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
summary(r)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
# Model Loop. Iterates over days and runs loess local polynomial regression
# with varying bandwith selections. The model regressors are from selection.R,
# using a general linear approach. Unit of analysis is country on day d.
masterData = masterData[masterData$total_cases < 5000000, ]
masterData = masterData[masterData$deltaGDP > -10000, ]
masterData = masterData[!is.na(masterData$lawRank), ]
# Begin model loop. Iterates over unique days and appends model statistics
# to globalData. Sum of squared error is most valuable here, allowing us to
# track the model's ability to predict the change in GDP from 2019 to 2020 over
# time.
x <- unique(c(masterData$date))
globalData = data.frame()
for (i in 0:length(x)) {
localData = masterData[masterData$date == x[i]]
if (length(localData$Country.or.Area) !=0) {
loessMod25 <- loess(deltaGDP ~lawRank, data=localData, span=0.25) # 25% smoothing span
smoothed25 <- predict(loessMod25)
loessMod50 <- loess(deltaGDP ~ lawRank, data=localData, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
loessMod75 <- loess(deltaGDP ~ lawRank, data=localData, span=0.75) # 50% smoothing span
smoothed75 <- predict(loessMod75)
localData = c(x[i], loessMod25$s, loessMod50$s, loessMod75$s)
globalData <- rbind(globalData, localData)
}
}
# Clean the returned data set
names(globalData)[1] = "date"
names(globalData)[2] = "mod25"
names(globalData)[3] = "mod50"
names(globalData)[4] = "mod75"
globalData$mod25 <- as.numeric(as.character(globalData$mod25))
globalData$mod50 <- as.numeric(as.character(globalData$mod50))
globalData$mod75 <- as.numeric(as.character(globalData$mod75))
globalData = globalData[!is.na(globalData$mod25), ]
# Plot the Results over time and bandwidth selections
dev.off()
plot(as.Date(globalData$date), globalData$mod25, col = "red", pch="+",
xlab="", ylab="", xaxt='n', yaxt='n')
par(new=TRUE)
plot(as.Date(globalData$date), globalData$mod50, col = "blue", pch="+",
xlab="", ylab="", xaxt='n', yaxt='n')
par(new=TRUE)
plot(as.Date(globalData$date), globalData$mod75, col = "green", pch="+",
main="Loess Prediction Error Over Time", xlab="Date", ylab="Root MSE",
)
#Select Best Day and Plot
bestDate = globalData$date[which(globalData$mod50 == min(globalData$mod50))]
bestDate = masterData[masterData$date == bestDate]
loessMod50 <- loess(deltaGDP ~ lawRank, data=bestDate, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
View(loessMod50)
loessMod50$s
worstDate = globalData$date[which(globalData$mod50 == max(globalData$mod50))]
worstDate = masterData[masterData$date == worstDate]
loessMod50 <- loess(deltaGDP ~ lawRank, data=worstDate, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
plot(worstDate$lawRank, worstDate$deltaGDP, col = "red", pch="+", xlab="",
ylab="", xaxt='n', yaxt='n')
par(new=TRUE)
plot(worstDate$lawRank, smoothed50, col = "blue", pch="+", xlab="Law Rank",
ylab="Change in GDP", main="Worst Day Model Prediction")
rm(list = ls())
loessMod50$s
#Select Worst Day and Plot
worstDate = globalData$date[which(globalData$mod50 == max(globalData$mod50))]
worstDate = masterData[masterData$date == worstDate]
loessMod50 <- loess(deltaGDP ~ lawRank, data=worstDate, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
loessMod50$s
plot(worstDate$lawRank, worstDate$deltaGDP, col = "red", pch="+", xlab="",
ylab="", xaxt='n', yaxt='n')
par(new=TRUE)
plot(worstDate$lawRank, smoothed50, col = "blue", pch="+", xlab="Law Rank",
ylab="Change in GDP", main="Worst Day Model Prediction")
rm(list = ls())
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
# Model Loop. Iterates over days and runs loess local polynomial regression
# with varying bandwith selections. The model regressors are from selection.R,
# using a general linear approach. Unit of analysis is country on day d.
masterData = masterData[masterData$total_cases < 5000000, ]
masterData = masterData[masterData$deltaGDP > -10000, ]
masterData = masterData[!is.na(masterData$lawRank), ]
# Begin model loop. Iterates over unique days and appends model statistics
# to globalData. Sum of squared error is most valuable here, allowing us to
# track the model's ability to predict the change in GDP from 2019 to 2020 over
# time.
x <- unique(c(masterData$date))
globalData = data.frame()
for (i in 0:length(x)) {
localData = masterData[masterData$date == x[i]]
if (length(localData$Country.or.Area) !=0) {
loessMod25 <- loess(deltaGDP ~lawRank, data=localData, span=0.25) # 25% smoothing span
smoothed25 <- predict(loessMod25)
loessMod50 <- loess(deltaGDP ~ lawRank, data=localData, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
loessMod75 <- loess(deltaGDP ~ lawRank, data=localData, span=0.75) # 50% smoothing span
smoothed75 <- predict(loessMod75)
localData = c(x[i], loessMod25$s, loessMod50$s, loessMod75$s)
globalData <- rbind(globalData, localData)
}
}
# Clean the returned data set
names(globalData)[1] = "date"
names(globalData)[2] = "mod25"
names(globalData)[3] = "mod50"
names(globalData)[4] = "mod75"
globalData$mod25 <- as.numeric(as.character(globalData$mod25))
globalData$mod50 <- as.numeric(as.character(globalData$mod50))
globalData$mod75 <- as.numeric(as.character(globalData$mod75))
globalData = globalData[!is.na(globalData$mod25), ]
# Plot the Results over time and bandwidth selections
dev.off()
plot(as.Date(globalData$date), globalData$mod25, col = "red", pch="+",
xlab="", ylab="", xaxt='n', yaxt='n')
par(new=TRUE)
plot(as.Date(globalData$date), globalData$mod50, col = "blue", pch="+",
xlab="", ylab="", xaxt='n', yaxt='n')
par(new=TRUE)
plot(as.Date(globalData$date), globalData$mod75, col = "green", pch="+",
main="Loess Prediction Error Over Time", xlab="Date", ylab="Root MSE",
)
#Select Best Day and Plot
bestDate = globalData$date[which(globalData$mod50 == min(globalData$mod50))]
bestDate = masterData[masterData$date == bestDate]
loessMod50 <- loess(deltaGDP ~ lawRank, data=bestDate, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
plot(bestDate$lawRank, bestDate$deltaGDP, col = "red", pch="+", xlab="",
ylab="", xaxt='n', yaxt='n')
par(new=TRUE)
plot(bestDate$lawRank, smoothed50, col = "blue", pch="+", xlab="Law Rank",
ylab="Change in GDP", main="Best Day Model Prediction")
#Select Worst Day and Plot
worstDate = globalData$date[which(globalData$mod50 == max(globalData$mod50))]
worstDate = masterData[masterData$date == worstDate]
loessMod50 <- loess(deltaGDP ~ lawRank, data=worstDate, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
loessMod50$s
plot(worstDate$lawRank, worstDate$deltaGDP, col = "red", pch="+", xlab="",
ylab="", xaxt='n', yaxt='n')
par(new=TRUE)
plot(worstDate$lawRank, smoothed50, col = "blue", pch="+", xlab="Law Rank",
ylab="Change in GDP", main="Worst Day Model Prediction")
rm(list = ls())
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
x <- unique(c(masterData$date))
r2s <- c(replicate(length(x), 0))
masterData = masterData[!is.na(masterData$total_deaths), ]
masterData = masterData[!is.na(masterData$stabilityRank), ]
masterData = masterData[!is.na(masterData$lawRank), ]
masterData = masterData[!is.na(masterData$accountRank), ]
masterData = masterData[masterData$total_deaths != 0.0, ]
masterData = masterData[masterData$stabilityRank != 0.0, ]
masterData = masterData[masterData$lawRank != 0.0, ]
masterData = masterData[masterData$accountRank != 0.0, ]
count = 0
for (index in 1:length(x)){
covidData <-  masterData[masterData$date == x[index]]
print(" ")
#Linear Regression
if (length(covidData$total_deaths) > 10){
r = lm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
r2s[index] <- summary(r)$r.squared
}else{
print(x[index])
count = count + 1
}
}
r2s[r2s == 1.0] = 0.0
for (ind in 1:length(r2s)){
if (r2s[ind] == max(r2s)){
print(x[ind])
}
}
covidData <-masterData[masterData$date == "2020-03-10"]
#Linear Regression
r = lm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
summary(r)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
x <- unique(c(masterData$date))
aics <- c(replicate(length(x), 0))
masterData = masterData[!is.na(masterData$total_deaths), ]
masterData = masterData[!is.na(masterData$stabilityRank), ]
masterData = masterData[!is.na(masterData$lawRank), ]
masterData = masterData[!is.na(masterData$accountRank), ]
masterData = masterData[masterData$total_deaths != 0.0, ]
masterData = masterData[masterData$stabilityRank != 0.0, ]
masterData = masterData[masterData$lawRank != 0.0, ]
masterData = masterData[masterData$accountRank != 0.0, ]
count = 0
for (index in 1:length(x)){
covidData <-  masterData[masterData$date == x[index]]
print(" ")
#Linear Regression
if (length(covidData$total_deaths) > 10){
r = glm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
aics[index] <- summary(r)$aic
}else{
print(x[index])
count = count + 1
}
}
aics[aics == -Inf] = Inf
aics[aics == 0.0] = Inf
for (ind in 1:length(aics)){
if (aics[ind] == min(aics)){
print(x[ind])
}
}
covidData <-masterData[masterData$date == "2020-03-08"]
#Linear Regression
r = glm(deltaGDP ~ total_deaths + stabilityRank  + lawRank + accountRank, data=covidData)
summary(r)
rm(list = ls())
source("dataBuild.R")
load("covidCorruption.RData")
# Model Loop. Iterates over days and runs loess local polynomial regression
# with varying bandwith selections. The model regressors are from selection.R,
# using a general linear approach. Unit of analysis is country on day d.
masterData = masterData[masterData$total_cases < 5000000, ]
masterData = masterData[masterData$deltaGDP > -10000, ]
masterData = masterData[!is.na(masterData$lawRank), ]
# Begin model loop. Iterates over unique days and appends model statistics
# to globalData. Sum of squared error is most valuable here, allowing us to
# track the model's ability to predict the change in GDP from 2019 to 2020 over
# time.
x <- unique(c(masterData$date))
globalData = data.frame()
for (i in 0:length(x)) {
localData = masterData[masterData$date == x[i]]
if (length(localData$Country.or.Area) !=0) {
loessMod25 <- loess(deltaGDP ~lawRank, data=localData, span=0.25) # 25% smoothing span
smoothed25 <- predict(loessMod25)
loessMod25$s
loessMod50 <- loess(deltaGDP ~ lawRank, data=localData, span=0.50) # 50% smoothing span
smoothed50 <- predict(loessMod50)
loessMod75 <- loess(deltaGDP ~ lawRank, data=localData, span=0.75) # 50% smoothing span
smoothed75 <- predict(loessMod75)
localData = c(x[i], loessMod25$s, loessMod50$s, loessMod75$s)
globalData <- rbind(globalData, localData)
}
}
loessMod25$s
loessMod50$s
loessMod75$s
data=masterData %>%
select(lawRank, accountRank, total_deaths,regulationRank, govRank,corruptionRank,total_cases,gdp_per_capita)
library(dplyr)
data=masterData %>%
select(lawRank, accountRank, total_deaths,regulationRank, govRank,corruptionRank,total_cases,gdp_per_capita)
cor(data)
data=masterData %>%group_by(Country.or.Area)
select(lawRank, accountRank, total_deaths,regulationRank, govRank,corruptionRank,total_cases,gdp_per_capita)
data=masterData %>%group_by(Country.or.Area)%>%
select(lawRank, accountRank, total_deaths,regulationRank, govRank,corruptionRank,total_cases,gdp_per_capita)
View(data)
data=masterData %>%
select(lawRank, accountRank, total_deaths,regulationRank, govRank,corruptionRank,total_cases,gdp_per_capita)
cor(data)
cor=cor(data)
corrplot(corr, method="circle")
install.packages("corrplot")
library(corrplot)
data=masterData %>%
select(lawRank, accountRank, total_deaths,regulationRank, govRank,corruptionRank,total_cases,gdp_per_capita)
cor=cor(data)
corrplot(corr, method="circle")
data=masterData %>%
select(lawRank, accountRank, total_deaths,regulationRank, govRank,corruptionRank,total_cases,gdp_per_capita)
cor=cor(data)
corrplot(cor, method="circle")
source("dataBuild.R")
load("covidCorruption.RData")
# Summary plots below are not too substantive. Goal is to visualize the new data
# and evidence our prediction argument. Note, our project pays no attention to a
# time series, where we have isolated the data from the last day in the dataset.
# What might be worthwhile, is including (down the road) line graphs connecting
# three points, for a handful of countries, over time. For example, Mar1, June1, Oct19.
#install.packages(c("cowplot","googleway", "ggplot2", "ggrepel",
#                   "ggspatial", "libwgeom", "sf", "rnaturalearth", "rnaturalearthdata",
#                   "rgeos", readxl))
library("readxl")
library(dplyr)
library(tidyr)
library("ggplot2")
theme_set(theme_bw())
library("sf")
library("rnaturalearth")
library("rnaturalearthdata")
library(rgeos)
#bringing in covid data alone to get the specific max case rate per country
covid<-read_excel("COVID.xlsx")
plot1 = ggplot(data =masterData, aes(x = lawRank, y = gdp_per_capita)) + geom_text(aes(label = Country.or.Area), size = 2) + geom_smooth(method = "lm")
plot2 = ggplot(data =masterData, aes(x = accountRank, y = gdp_per_capita)) + geom_text(aes(label = Country.or.Area), size = 2) + geom_smooth(method = "lm")
plot3 = ggplot(data =masterData, aes(x = stabilityRank, y = gdp_per_capita)) + geom_text(aes(label = Country.or.Area), size = 2) + geom_smooth(method = "lm")
plot4 = ggplot(data =masterData, aes(x = total_deaths, y = gdp_per_capita))  + geom_smooth(method = "lm")
plot5 = ggplot(data =masterData, aes(x = regulationRank, y = gdp_per_capita)) + geom_text(aes(label = Country.or.Area), size = 2) + geom_smooth(method = "lm")
plot6 = ggplot(data =masterData, aes(x = govRank, y = gdp_per_capita)) + geom_text(aes(label = Country.or.Area), size = 2) + geom_smooth(method = "lm")
plot7 = ggplot(data =masterData, aes(x = corruptionRank, y = gdp_per_capita)) + geom_text(aes(label = Country.or.Area), size = 2) + geom_smooth(method = "lm")
plot8 = ggplot(data =masterData, aes(x = total_cases, y = gdp_per_capita)) + geom_smooth(method = "lm")
plot1
plot2
plot3
plot4 = ggplot(data =masterData, aes(x = total_deaths, y = gdp_per_capita))  + geom_text(aes(label = Country.or.Area), size = 2) +geom_smooth(method = "lm")
plot8 = ggplot(data =masterData, aes(x = total_cases, y = gdp_per_capita)) + geom_text(aes(label = Country.or.Area), size = 2) +geom_smooth(method = "lm")
plot4
plot3 = ggplot(data =masterData, aes(x = stabilityRank, y = gdp_per_capita)) + geom_smooth(method = "lm")
plot4
View(masterData)
plot4 = ggplot(data =masterData, aes(x = total_deaths, y = gdp_per_capita))  +geom_smooth(method = "lm")
plot4
plot3 = ggplot(data =masterData, aes(x = stabilityRank, y = gdp_per_capita)) + geom_text(aes(label = Country.or.Area), size = 2) + geom_smooth(method = "lm")
plot3
plot4 = ggplot(data =masterData, aes(x = total_deaths, y = gdp_per_capita))   +geom_smooth(method = "lm")
plot4
plot5 = ggplot(data =masterData, aes(x = regulationRank, y = gdp_per_capita)) + geom_text(aes(label = Country.or.Area), size = 2) + geom_smooth(method = "lm")
plot5
plot6
plot7
plot8 = ggplot(data =masterData, aes(x = total_cases, y = gdp_per_capita)) +geom_smooth(method = "lm")
plot8
#adding case rate to covid data and creating a new data frame with just the countries and their max case rate
covid<-covid%>%drop_na(total_cases, population, gdp_per_capita)
covid$caseRatePer100k = covid$total_cases/(covid$population/100000)
covid_max_rate_df<-covid%>%group_by(location)%>%summarise(max(caseRatePer100k))
#using ne_countries to get map of countries
world <- ne_countries(scale = "medium", returnclass = "sf")
#merging world df with covid_max_rate_df to plot and renaming column
world_1=merge(world, covid_max_rate_df, by.x="name", by.y="location")
names(world_1)[names(world_1) == "max(caseRatePer100k)"] <- "max_case_rate"
#merging world with masterData df to plot percent change in gdp from 2019 to 2020
masterData<-masterData%>%drop_na(gdp2020)
percent_change_gdp=masterData%>%group_by(Country.or.Area)%>%summarise((gdp2020-gdp2019)/gdp2020)
percent_change_gdp=unique(percent_change_gdp)
names(percent_change_gdp)[names(percent_change_gdp) == "(gdp2020 - gdp2019)/gdp2020"] <- "percent_change_gdp"
percent_change_gdp$percent_change_gdp=abs(percent_change_gdp$percent_change_gdp)
world_2=merge(world, percent_change_gdp, by.x="name", by.y="Country.or.Area")
#merging world and master data to get lawrank graphed
lawrank=masterData %>%
select(Country.or.Area, lawRank)
lawrank=unique(lawrank)
world_3=merge(world, lawrank, by.x="name", by.y="Country.or.Area")
#world plot of max case rate per country
ggplot(data = world_1) +
geom_sf(aes(fill = max_case_rate)) +
scale_fill_viridis_c(option = "plasma", trans = "sqrt")
ggplot(data = world_2) +
geom_sf(aes(fill = percent_change_gdp)) +
scale_fill_viridis_c(option = "plasma", trans = "sqrt")
ggplot(data = world_3) +
geom_sf(aes(fill = lawRank)) +
scale_fill_viridis_c(option = "plasma", trans = "sqrt")
